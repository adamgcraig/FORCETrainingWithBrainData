function nn = init_izhikevich_neurons()
%UNTITLED7 Summary of this function goes here
%   Detailed explanation goes here
%% Set the Izhikevich neuron model constants.

dt = 0.04;% ms, Euler integration step size
I_bias = 1000.0;% pA, constant bias current
C = 250.0;% microF, membrane capacitance
k = 2.5;% ns/mV, scaling factor of action potential half-width
v_peak = 30.0;% mV, peak voltage, maximum v attained during a spike
v_reset = -65.0;% mV, reset potential, v becomes this after a spike
v_resting = -60.0;% mV, resting v
v_threshold = -40.0;% mV, threshold v (when b=0 and I_bias=0)
a = 0.002;% ms^-1, reciprocal of u time constant
% If we set b to something non-0, go back into the code and swap back in the version of the u and v updates that uses b.
b = 0.0;% nS, sensitivity of u to subthreshold oscillations of v
d = 100.0;% pA, incremental increase in u after each spike
tau_d = 20.0;% ms, synaptic decay time
tau_r = 2.0;% ms, synaptic rise time

%% Pre-calculate some combinations of the above constants.

dt_over_C = dt / C;
dt_a = dt * a;
one_minus_dt_a = 1 - dt_a;
dt_a_b = dt_a * b;
exp_neg_dt_over_tau_d = exp(-dt / tau_d);
exp_neg_dt_over_tau_r = exp(-dt / tau_r);
one_over_tr_td = 1 / (tau_r * tau_d);

%% Randomly generate the fixed network topology.

num_neurons = 1000;% number of neurons in reservoir network
reservoir_density = 0.1;% connection density of reservoir network
is_connected = rand(num_neurons,num_neurons) < reservoir_density;
reservoir_weights_no_G = zeros(num_neurons,num_neurons);% static weights of reservoir network
reservoir_weights_no_G(is_connected) = randn( [nnz(is_connected) 1] )/( reservoir_density*sqrt(num_neurons) );

num_predicted_areas = 1;% dimensionality of time series to learn
num_neighbor_areas = 2;% number of context cue time series
num_area_features = 4;% number of constant context cures
% Fixed network weight matrices
prediction_input_weights_no_Q = 2*rand([num_neurons num_predicted_areas]) - 1;% static encoding weights of prediction fed back into network
neighbor_input_weights_no_Q = 2*rand([num_neurons num_neighbor_areas]) - 1;% static encoding weights of neighbor activities
area_feature_input_weights_no_Q = 2*rand([num_neurons num_area_features]) - 1;% static encoding weights of neighbor activities

%% Scale the fixed weight matrices.

G = 5000;% global weighting factor of reservoir connections
Q_predicted = 400;% /num_predicted_areas;% weighting factor for predicted activity fed back as input
Q_neighbor= 4000;% /num_neighbor_areas;% weighting factor for neighbor activity
Q_area_features = 4000;% /num_area_features;% weighting factor for area features
reservoir_weights = gpuArray(G*reservoir_weights_no_G);
prediction_input_weights = gpuArray(Q_predicted*prediction_input_weights_no_Q);% static encoding weights of prediction fed back into network
neighbor_input_weights = gpuArray( Q_neighbor*neighbor_input_weights_no_Q );% static encoding weights of neighbor activities
area_feature_input_weights = gpuArray( Q_area_features*area_feature_input_weights_no_Q );% static encoding weights of neighbor activities

%% Set the initial neuron state vectors and RLS matrices.

% Neuron state vectors
I_synapse = gpuArray( zeros([num_neurons 1]) );% pA, post-synaptic current
v = gpuArray( v_resting + (v_peak - v_resting)*rand([num_neurons 1]) );% mV, membrane potential
u = gpuArray( zeros([num_neurons 1]) );% pA, adaptation current
h = gpuArray( zeros([num_neurons 1]) );% pA/ms, synaptic current gating variable?
hr = gpuArray( zeros([num_neurons 1]) );% pA/ms, output current gating variable?
r = gpuArray( zeros([num_neurons 1]) );% pA, network output before transformation by output weights
% State matrices used in FORCE training
P = gpuArray( 2*eye([num_neurons num_neurons]) );% "network estimate of the inverse of the correlation matrix" according to the paper
output_weights = gpuArray( zeros([num_predicted_areas num_neurons]) );% output weights used to generate prediction from r
prediction = gpuArray( zeros([num_predicted_areas 1]) );% predicted value of the time series.

nn = struct( ...
    'dt',dt, ...
    'I_bias',I_bias, ...
    'C',C, ...
    'k',k, ...
    'v_peak',v_peak, ...
    'v_reset',v_reset, ...
    'v_resting',v_resting, ...
    'v_threshold',v_threshold, ...
    'a',a, ...
    'b',b, ...
    'd',d, ...
    'tau_d',tau_d, ...
    'tau_r',tau_r, ...
    'dt_over_C',dt_over_C, ...
    'dt_a',dt_a, ...
    'one_minus_dt_a',one_minus_dt_a, ...
    'dt_a_b',dt_a_b, ...
    'exp_neg_dt_over_tau_d', exp_neg_dt_over_tau_d, ...
    'exp_neg_dt_over_tau_r', exp_neg_dt_over_tau_r, ...
    'one_over_tr_td', one_over_tr_td, ...
    'num_neurons', num_neurons, ...
    'reservoir_density', reservoir_density, ...
    'is_connected', is_connected, ...
    'reservoir_weights_no_G', reservoir_weights_no_G, ...
    'num_predicted_areas', num_predicted_areas, ...
    'num_neighbor_areas', num_neighbor_areas, ...
    'num_area_features', num_area_features, ...
    'prediction_input_weights_no_Q', prediction_input_weights_no_Q, ...
    'neighbor_input_weights_no_Q', neighbor_input_weights_no_Q, ...
    'area_feature_input_weights_no_Q', area_feature_input_weights_no_Q, ...
    'G', G, ...
    'Q_predicted', Q_predicted, ...
    'Q_neighbor', Q_neighbor, ...
    'Q_area_features', Q_area_features, ...
    'reservoir_weights', reservoir_weights, ...
    'prediction_input_weights', prediction_input_weights, ...
    'neighbor_input_weights', neighbor_input_weights, ...
    'area_feature_input_weights', area_feature_input_weights, ...
    'I_synapse', I_synapse, ...
    'v', v, ...
    'u', u, ...
    'h', h, ...
    'hr', hr, ...
    'r', r, ...
    'P', P, ...
    'output_weights', output_weights, ...
    'prediction', prediction ...
    );

end